# Auth bundle
- Generated: 2025-12-31T12:30:54
- Project root: `/Users/lamontenunn/AFT/aft_firebase_app`

---

## `lib/main.dart`
```dart
   1 | import 'package:flutter/material.dart';
   2 | import 'package:flutter/foundation.dart';
   3 | import 'package:flutter/services.dart';
   4 | import 'package:flutter_riverpod/flutter_riverpod.dart';
   5 | import 'package:firebase_core/firebase_core.dart';
   6 | import 'package:firebase_auth/firebase_auth.dart';
   7 | import 'firebase_options.dart';
   8 | import 'app.dart';
   9 | import 'features/aft/logic/data/mdl_csv.dart';
  10 | import 'features/aft/logic/data/hrp_csv.dart';
  11 | import 'features/aft/logic/data/sdc_csv.dart';
  12 | import 'features/aft/logic/data/plk_csv.dart';
  13 | import 'features/aft/logic/data/run2mi_csv.dart';
  14 | 
  15 | Future<void> main() async {
  16 |   WidgetsFlutterBinding.ensureInitialized();
  17 | 
  18 |   // Lock the entire app to portrait so rotating the device does not change layout.
  19 |   await SystemChrome.setPreferredOrientations([
  20 |     DeviceOrientation.portraitUp,
  21 |   ]);
  22 | 
  23 |   await Firebase.initializeApp(
  24 |     options: DefaultFirebaseOptions.currentPlatform,
  25 |   );
  26 | 
  27 |   // Auth Emulator disabled: using real Firebase backend.
  28 |   // To re-enable for local testing, restore useAuthEmulator() in debug builds.
  29 |   // Load MDL, HRP, and SDC scoring tables (male/female, age-banded) from embedded CSVs
  30 |   preloadMdlCsvOnce(mdlCsv);
  31 |   preloadHrpCsvOnce(hrpCsv);
  32 |   preloadSdcCsvOnce(sdcCsv);
  33 |   preloadPlkCsvOnce(plkCsv);
  34 |   preloadRun2miCsvOnce(run2miCsv);
  35 |   runApp(const ProviderScope(child: App()));
  36 | }
```

---

## `lib/firebase_options.dart`
```dart
   1 | // File generated by FlutterFire CLI.
   2 | // ignore_for_file: type=lint
   3 | import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
   4 | import 'package:flutter/foundation.dart'
   5 |     show defaultTargetPlatform, kIsWeb, TargetPlatform;
   6 | 
   7 | /// Default [FirebaseOptions] for use with your Firebase apps.
   8 | ///
   9 | /// Example:
  10 | /// ```dart
  11 | /// import 'firebase_options.dart';
  12 | /// // ...
  13 | /// await Firebase.initializeApp(
  14 | ///   options: DefaultFirebaseOptions.currentPlatform,
  15 | /// );
  16 | /// ```
  17 | class DefaultFirebaseOptions {
  18 |   static FirebaseOptions get currentPlatform {
  19 |     if (kIsWeb) {
  20 |       return web;
  21 |     }
  22 |     switch (defaultTargetPlatform) {
  23 |       case TargetPlatform.android:
  24 |         return android;
  25 |       case TargetPlatform.iOS:
  26 |         return ios;
  27 |       case TargetPlatform.macOS:
  28 |         return macos;
  29 |       case TargetPlatform.windows:
  30 |         return windows;
  31 |       case TargetPlatform.linux:
  32 |         throw UnsupportedError(
  33 |           'DefaultFirebaseOptions have not been configured for linux - '
  34 |           'you can reconfigure this by running the FlutterFire CLI again.',
  35 |         );
  36 |       default:
  37 |         throw UnsupportedError(
  38 |           'DefaultFirebaseOptions are not supported for this platform.',
  39 |         );
  40 |     }
  41 |   }
  42 | 
  43 |   static const FirebaseOptions web = FirebaseOptions(
  44 |     apiKey: 'AIzaSyB-XaKExTgOrBVFHQ4paOUQmTtiRLlgjnU',
  45 |     appId: '1:109820847091:web:125882894ebbdee265a886',
  46 |     messagingSenderId: '109820847091',
  47 |     projectId: 'aft-firebase-app-1760071390',
  48 |     authDomain: 'aft-firebase-app-1760071390.firebaseapp.com',
  49 |     storageBucket: 'aft-firebase-app-1760071390.firebasestorage.app',
  50 |   );
  51 | 
  52 |   static const FirebaseOptions android = FirebaseOptions(
  53 |     apiKey: 'AIzaSyC0CzPojuDi5_5eEkzNHANg89S7oQgi3Ew',
  54 |     appId: '1:109820847091:android:e992649ee0b026bc65a886',
  55 |     messagingSenderId: '109820847091',
  56 |     projectId: 'aft-firebase-app-1760071390',
  57 |     storageBucket: 'aft-firebase-app-1760071390.firebasestorage.app',
  58 |   );
  59 | 
  60 |   static const FirebaseOptions ios = FirebaseOptions(
  61 |     apiKey: 'AIzaSyC7IYCyExhiNpMYReqU-qLwidj-90q5-Iw',
  62 |     appId: '1:109820847091:ios:e3f686da70448e6765a886',
  63 |     messagingSenderId: '109820847091',
  64 |     projectId: 'aft-firebase-app-1760071390',
  65 |     storageBucket: 'aft-firebase-app-1760071390.firebasestorage.app',
  66 |     iosBundleId: 'com.lamontenunn.aftApp',
  67 |   );
  68 | 
  69 |   static const FirebaseOptions macos = FirebaseOptions(
  70 |     apiKey: 'AIzaSyC7IYCyExhiNpMYReqU-qLwidj-90q5-Iw',
  71 |     appId: '1:109820847091:ios:f079a741dda0bc9665a886',
  72 |     messagingSenderId: '109820847091',
  73 |     projectId: 'aft-firebase-app-1760071390',
  74 |     storageBucket: 'aft-firebase-app-1760071390.firebasestorage.app',
  75 |     iosBundleId: 'com.example.aftFirebaseApp',
  76 |   );
  77 | 
  78 |   static const FirebaseOptions windows = FirebaseOptions(
  79 |     apiKey: 'AIzaSyB-XaKExTgOrBVFHQ4paOUQmTtiRLlgjnU',
  80 |     appId: '1:109820847091:web:b5291917741a6d7465a886',
  81 |     messagingSenderId: '109820847091',
  82 |     projectId: 'aft-firebase-app-1760071390',
  83 |     authDomain: 'aft-firebase-app-1760071390.firebaseapp.com',
  84 |     storageBucket: 'aft-firebase-app-1760071390.firebasestorage.app',
  85 |   );
  86 | 
  87 | }```

---

## `lib/features/auth/auth_gate.dart`
```dart
   1 | import 'package:flutter/material.dart';
   2 | import 'package:flutter_riverpod/flutter_riverpod.dart';
   3 | 
   4 | import 'package:aft_firebase_app/features/auth/providers.dart';
   5 | import 'package:aft_firebase_app/features/auth/sign_in_page.dart';
   6 | 
   7 | /// AuthGate renders the appropriate screen depending on auth state:
   8 | /// - Loading: progress indicator
   9 | /// - Signed out: SignInPage
  10 | /// - Signed in: provided child
  11 | class AuthGate extends ConsumerWidget {
  12 |   const AuthGate({super.key, required this.child});
  13 | 
  14 |   final Widget child;
  15 | 
  16 |   @override
  17 |   Widget build(BuildContext context, WidgetRef ref) {
  18 |     final asyncUser = ref.watch(firebaseUserProvider);
  19 | 
  20 |     return asyncUser.when(
  21 |       data: (user) {
  22 |         if (user == null) {
  23 |           // Not signed in -> show Sign In/Sign Up first screen
  24 |           return const SignInPage();
  25 |         }
  26 |         // Signed in -> render the intended child
  27 |         return child;
  28 |       },
  29 |       loading: () => const Scaffold(
  30 |         body: Center(child: CircularProgressIndicator()),
  31 |       ),
  32 |       error: (err, stack) => Scaffold(
  33 |         body: Center(
  34 |           child: Column(
  35 |             mainAxisSize: MainAxisSize.min,
  36 |             children: [
  37 |               const Icon(Icons.error_outline, size: 28),
  38 |               const SizedBox(height: 8),
  39 |               Text('Failed to load auth state', style: Theme.of(context).textTheme.bodyMedium),
  40 |             ],
  41 |           ),
  42 |         ),
  43 |       ),
  44 |     );
  45 |   }
  46 | }
```

---

## `lib/features/auth/auth_side_effects.dart`
```dart
   1 | import 'package:firebase_auth/firebase_auth.dart';
   2 | import 'package:flutter_riverpod/flutter_riverpod.dart';
   3 | 
   4 | import 'package:aft_firebase_app/features/auth/providers.dart';
   5 | import 'package:aft_firebase_app/features/saves/guest_migration.dart';
   6 | import 'package:aft_firebase_app/features/saves/editing.dart';
   7 | import 'package:aft_firebase_app/data/repository_providers.dart';
   8 | import 'package:aft_firebase_app/state/settings_state.dart';
   9 | 
  10 | /// Auth transition listener for migration and user-scoped state resets.
  11 | final authSideEffectsProvider = Provider<void>((ref) {
  12 |   ref.listen<AsyncValue<User?>>(
  13 |     firebaseUserProvider,
  14 |     (previous, next) {
  15 |       final prevUser = previous?.asData?.value;
  16 |       final user = next.asData?.value;
  17 | 
  18 |       if (prevUser?.uid != user?.uid) {
  19 |         ref.read(editingSetProvider.notifier).state = null;
  20 |         ref.invalidate(aftRepositoryProvider);
  21 |         ref.invalidate(settingsProvider);
  22 |       }
  23 | 
  24 |       if (user == null) return;
  25 | 
  26 |       if (user.isAnonymous) {
  27 |         GuestMigration.trackGuestUser(user.uid);
  28 |         return;
  29 |       }
  30 | 
  31 |       final prevWasAnon = prevUser?.isAnonymous ?? false;
  32 |       if (prevWasAnon || prevUser?.uid != user.uid) {
  33 |         GuestMigration.maybeMigrateGuestTo(user.uid);
  34 |       }
  35 |     },
  36 |     fireImmediately: true,
  37 |   );
  38 | });
```

---

## `lib/features/auth/providers.dart`
```dart
   1 | import 'package:flutter_riverpod/flutter_riverpod.dart';
   2 | import 'package:firebase_auth/firebase_auth.dart';
   3 | import 'package:firebase_core/firebase_core.dart';
   4 | import 'package:aft_firebase_app/features/auth/auth_state.dart';
   5 | 
   6 | /// Expose FirebaseAuth instance
   7 | final firebaseAuthProvider = Provider<FirebaseAuth?>((ref) {
   8 |   // In tests (or before Firebase.initializeApp), avoid touching FirebaseAuth.
   9 |   if (Firebase.apps.isEmpty) return null;
  10 |   return FirebaseAuth.instance;
  11 | });
  12 | 
  13 | /// Firebase user stream
  14 | final firebaseUserProvider = StreamProvider<User?>((ref) {
  15 |   final auth = ref.watch(firebaseAuthProvider);
  16 |   // If Firebase isn't initialized (e.g., tests), appear signed out.
  17 |   if (auth == null) return Stream<User?>.value(null);
  18 |   return auth.authStateChanges();
  19 | });
  20 | 
  21 | /// Current Firebase user (fallback to currentUser while stream loads).
  22 | final authUserProvider = Provider<User?>((ref) {
  23 |   final asyncUser = ref.watch(firebaseUserProvider);
  24 |   final auth = ref.watch(firebaseAuthProvider);
  25 |   return asyncUser.maybeWhen(
  26 |     data: (user) => user,
  27 |     orElse: () => auth?.currentUser,
  28 |   );
  29 | });
  30 | 
  31 | /// Map Firebase user to our AuthState (non-async for easy consumption in UI)
  32 | final authStateProvider = Provider<AuthState>((ref) {
  33 |   final user = ref.watch(authUserProvider);
  34 |   if (user == null) {
  35 |     return const AuthState.signedOut();
  36 |   }
  37 |   return AuthState.signedIn(
  38 |     userId: user.uid,
  39 |     displayName: user.displayName,
  40 |     photoUrl: user.photoURL,
  41 |   );
  42 | });
  43 | 
  44 | /// True when the current user is anonymous.
  45 | final isGuestUserProvider = Provider<bool>((ref) {
  46 |   final user = ref.watch(authUserProvider);
  47 |   return user != null && user.isAnonymous;
  48 | });
  49 | 
  50 | /// Convenience provider to expose auth actions
  51 | final effectiveUserIdProvider = Provider<String>((ref) {
  52 |   final user = ref.watch(authUserProvider);
  53 |   if (user == null) return 'signed-out';
  54 |   if (user.isAnonymous) return 'guest:${user.uid}';
  55 |   return user.uid;
  56 | });
  57 | 
  58 | final authActionsProvider = Provider<_AuthActions>((ref) {
  59 |   final auth = ref.read(firebaseAuthProvider);
  60 |   return _AuthActions(
  61 |     signInAnonymously: () {
  62 |       if (auth == null) {
  63 |         return Future.error(StateError('Auth not initialized'));
  64 |       }
  65 |       return auth.signInAnonymously();
  66 |     },
  67 |     signOut: () {
  68 |       if (auth == null) {
  69 |         return Future.error(StateError('Auth not initialized'));
  70 |       }
  71 |       return auth.signOut();
  72 |     },
  73 |   );
  74 | });
  75 | 
  76 | class _AuthActions {
  77 |   const _AuthActions({
  78 |     required this.signInAnonymously,
  79 |     required this.signOut,
  80 |   });
  81 | 
  82 |   final Future<UserCredential> Function() signInAnonymously;
  83 |   final Future<void> Function() signOut;
  84 | }
```

---

## `lib/features/auth/auth_state.dart`
```dart
   1 | import 'package:flutter/foundation.dart';
   2 | 
   3 | @immutable
   4 | class AuthState {
   5 |   final bool isSignedIn;
   6 |   final String? userId;
   7 |   final String? displayName;
   8 |   final String? photoUrl;
   9 | 
  10 |   const AuthState({
  11 |     required this.isSignedIn,
  12 |     this.userId,
  13 |     this.displayName,
  14 |     this.photoUrl,
  15 |   });
  16 | 
  17 |   const AuthState.signedOut()
  18 |       : isSignedIn = false,
  19 |         userId = null,
  20 |         displayName = null,
  21 |         photoUrl = null;
  22 | 
  23 |   const AuthState.signedIn({
  24 |     required String userId,
  25 |     String? displayName,
  26 |     String? photoUrl,
  27 |   })  : isSignedIn = true,
  28 |         userId = userId,
  29 |         displayName = displayName,
  30 |         photoUrl = photoUrl;
  31 | 
  32 |   AuthState copyWith({
  33 |     bool? isSignedIn,
  34 |     String? userId,
  35 |     String? displayName,
  36 |     String? photoUrl,
  37 |   }) {
  38 |     return AuthState(
  39 |       isSignedIn: isSignedIn ?? this.isSignedIn,
  40 |       userId: userId ?? this.userId,
  41 |       displayName: displayName ?? this.displayName,
  42 |       photoUrl: photoUrl ?? this.photoUrl,
  43 |     );
  44 |   }
  45 | }
```

---

## `lib/features/auth/sign_in_page.dart`
```dart
   1 | import 'package:flutter/material.dart';
   2 | import 'package:flutter_riverpod/flutter_riverpod.dart';
   3 | import 'package:aft_firebase_app/features/auth/providers.dart';
   4 | import 'package:aft_firebase_app/features/saves/guest_migration.dart';
   5 | import 'package:firebase_auth/firebase_auth.dart';
   6 | 
   7 | class SignInPage extends ConsumerStatefulWidget {
   8 |   const SignInPage({super.key});
   9 | 
  10 |   @override
  11 |   ConsumerState<SignInPage> createState() => _SignInPageState();
  12 | }
  13 | 
  14 | class _SignInPageState extends ConsumerState<SignInPage> {
  15 |   final _emailController = TextEditingController();
  16 |   final _passwordController = TextEditingController();
  17 |   final _confirmController = TextEditingController();
  18 |   final _formKey = GlobalKey<FormState>();
  19 |   bool _isRegistering = false;
  20 |   bool _showPassword = false;
  21 |   bool _showConfirm = false;
  22 |   bool _submitting = false;
  23 |   bool _resetting = false;
  24 |   String? _error;
  25 |   String? _info;
  26 | 
  27 |   void _setStateIfMounted(VoidCallback fn) {
  28 |     if (!mounted) return;
  29 |     setState(fn);
  30 |   }
  31 | 
  32 |   String _friendlyAuthError(FirebaseAuthException e) {
  33 |     switch (e.code) {
  34 |       case 'invalid-email':
  35 |         return 'Enter a valid email address.';
  36 |       case 'user-disabled':
  37 |         return 'This account has been disabled.';
  38 |       case 'user-not-found':
  39 |         return 'No user found for that email.';
  40 |       case 'wrong-password':
  41 |         return 'Incorrect password.';
  42 |       case 'email-already-in-use':
  43 |         return 'An account already exists for that email.';
  44 |       case 'credential-already-in-use':
  45 |         return 'That email is already linked to another account.';
  46 |       case 'weak-password':
  47 |         return 'Password must be at least 6 characters.';
  48 |       case 'operation-not-allowed':
  49 |         return 'Email/password sign-in is not enabled for this Firebase project.';
  50 |       case 'too-many-requests':
  51 |         return 'Too many requests. Try again later.';
  52 |       case 'network-request-failed':
  53 |         return 'Network error. Check your connection and try again.';
  54 |       default:
  55 |         return e.message ?? 'Authentication failed.';
  56 |     }
  57 |   }
  58 | 
  59 |   String? _validateEmail(String? value) {
  60 |     final text = value?.trim() ?? '';
  61 |     if (text.isEmpty) return 'Enter your email';
  62 |     if (!text.contains('@') || !text.contains('.')) {
  63 |       return 'Enter a valid email address';
  64 |     }
  65 |     return null;
  66 |   }
  67 | 
  68 |   String? _validatePassword(String? value) {
  69 |     final text = value ?? '';
  70 |     if (text.isEmpty) return 'Enter your password';
  71 |     if (text.length < 6) return 'Password must be at least 6 characters';
  72 |     return null;
  73 |   }
  74 | 
  75 |   String? _validateConfirm(String? value) {
  76 |     if (!_isRegistering) return null;
  77 |     if (value == null || value.isEmpty) return 'Confirm your password';
  78 |     if (value != _passwordController.text) return 'Passwords do not match';
  79 |     return null;
  80 |   }
  81 | 
  82 |   Future<void> _submit() async {
  83 |     final auth = ref.read(firebaseAuthProvider);
  84 |     if (auth == null) {
  85 |       _setStateIfMounted(() => _error = 'Auth not initialized');
  86 |       return;
  87 |     }
  88 |     final valid = _formKey.currentState?.validate() ?? false;
  89 |     if (!valid) return;
  90 | 
  91 |     _setStateIfMounted(() {
  92 |       _submitting = true;
  93 |       _error = null;
  94 |       _info = null;
  95 |     });
  96 |     FocusScope.of(context).unfocus();
  97 |     try {
  98 |       final email = _emailController.text.trim();
  99 |       final password = _passwordController.text;
 100 |       final currentUser = auth.currentUser;
 101 |       if (_isRegistering) {
 102 |         if (currentUser != null && currentUser.isAnonymous) {
 103 |           final credential = EmailAuthProvider.credential(
 104 |             email: email,
 105 |             password: password,
 106 |           );
 107 |           await currentUser.linkWithCredential(credential);
 108 |         } else {
 109 |           await auth.createUserWithEmailAndPassword(
 110 |             email: email,
 111 |             password: password,
 112 |           );
 113 |         }
 114 |       } else {
 115 |         await auth.signInWithEmailAndPassword(
 116 |           email: email,
 117 |           password: password,
 118 |         );
 119 |       }
 120 |       if (mounted && Navigator.of(context).canPop()) {
 121 |         Navigator.of(context).pop();
 122 |       }
 123 |     } on FirebaseAuthException catch (e) {
 124 |       _setStateIfMounted(() => _error = _friendlyAuthError(e));
 125 |     } catch (e) {
 126 |       _setStateIfMounted(() => _error = 'Authentication failed: $e');
 127 |     } finally {
 128 |       _setStateIfMounted(() => _submitting = false);
 129 |     }
 130 |   }
 131 | 
 132 |   Future<void> _sendPasswordReset() async {
 133 |     final auth = ref.read(firebaseAuthProvider);
 134 |     if (auth == null) {
 135 |       _setStateIfMounted(() => _error = 'Auth not initialized');
 136 |       return;
 137 |     }
 138 |     final email = _emailController.text.trim();
 139 |     if (email.isEmpty) {
 140 |       _setStateIfMounted(() => _error = 'Enter your email to reset password');
 141 |       return;
 142 |     }
 143 | 
 144 |     _setStateIfMounted(() {
 145 |       _resetting = true;
 146 |       _error = null;
 147 |       _info = null;
 148 |     });
 149 |     FocusScope.of(context).unfocus();
 150 |     try {
 151 |       await auth.sendPasswordResetEmail(email: email);
 152 |       _setStateIfMounted(
 153 |         () => _info = 'Password reset email sent to $email',
 154 |       );
 155 |     } on FirebaseAuthException catch (e) {
 156 |       _setStateIfMounted(() => _error = _friendlyAuthError(e));
 157 |     } catch (e) {
 158 |       _setStateIfMounted(() => _error = 'Failed to send reset email: $e');
 159 |     } finally {
 160 |       _setStateIfMounted(() => _resetting = false);
 161 |     }
 162 |   }
 163 | 
 164 |   Future<void> _signInAnonymously() async {
 165 |     _setStateIfMounted(() {
 166 |       _error = null;
 167 |       _info = null;
 168 |     });
 169 |     try {
 170 |       final cred = await ref.read(authActionsProvider).signInAnonymously();
 171 |       final user = cred.user;
 172 |       if (user != null) {
 173 |         await GuestMigration.trackGuestUser(user.uid);
 174 |       }
 175 |       if (mounted && Navigator.of(context).canPop()) {
 176 |         Navigator.of(context).pop();
 177 |       }
 178 |     } on FirebaseAuthException catch (e) {
 179 |       _setStateIfMounted(() => _error = _friendlyAuthError(e));
 180 |     } catch (e) {
 181 |       _setStateIfMounted(() => _error = 'Anonymous sign-in failed: $e');
 182 |     }
 183 |   }
 184 | 
 185 |   @override
 186 |   void dispose() {
 187 |     _emailController.dispose();
 188 |     _passwordController.dispose();
 189 |     _confirmController.dispose();
 190 |     super.dispose();
 191 |   }
 192 | 
 193 |   @override
 194 |   Widget build(BuildContext context) {
 195 |     final user = ref.watch(authUserProvider);
 196 |     final isSignedIn = user != null;
 197 |     final canSubmit = !_submitting && !_resetting;
 198 | 
 199 |     return Scaffold(
 200 |       appBar: AppBar(
 201 |         title: const Text('Sign in'),
 202 |       ),
 203 |       body: SafeArea(
 204 |         child: ListView(
 205 |           padding: const EdgeInsets.all(16),
 206 |           children: [
 207 |             Text(
 208 |               'Email',
 209 |               style: Theme.of(context)
 210 |                   .textTheme
 211 |                   .titleMedium
 212 |                   ?.copyWith(fontWeight: FontWeight.bold),
 213 |             ),
 214 |             const SizedBox(height: 8),
 215 |             Form(
 216 |               key: _formKey,
 217 |               child: AutofillGroup(
 218 |                 child: Column(
 219 |                   children: [
 220 |                     TextFormField(
 221 |                       controller: _emailController,
 222 |                       keyboardType: TextInputType.emailAddress,
 223 |                       textInputAction: TextInputAction.next,
 224 |                       textCapitalization: TextCapitalization.none,
 225 |                       autofillHints: const [AutofillHints.email],
 226 |                       decoration: const InputDecoration(
 227 |                         labelText: 'Email',
 228 |                         hintText: 'name@example.com',
 229 |                       ),
 230 |                       validator: _validateEmail,
 231 |                       enabled: canSubmit,
 232 |                     ),
 233 |                     const SizedBox(height: 8),
 234 |                     TextFormField(
 235 |                       controller: _passwordController,
 236 |                       textInputAction:
 237 |                           _isRegistering ? TextInputAction.next : TextInputAction.done,
 238 |                       obscureText: !_showPassword,
 239 |                       autocorrect: false,
 240 |                       enableSuggestions: false,
 241 |                       autofillHints: const [AutofillHints.password],
 242 |                       decoration: InputDecoration(
 243 |                         labelText: 'Password',
 244 |                         suffixIcon: IconButton(
 245 |                           tooltip: _showPassword ? 'Hide password' : 'Show password',
 246 |                           icon: Icon(
 247 |                             _showPassword ? Icons.visibility_off : Icons.visibility,
 248 |                           ),
 249 |                           onPressed: () {
 250 |                             setState(() => _showPassword = !_showPassword);
 251 |                           },
 252 |                         ),
 253 |                       ),
 254 |                       validator: _validatePassword,
 255 |                       enabled: canSubmit,
 256 |                       onFieldSubmitted: (_) {
 257 |                         if (!_isRegistering) _submit();
 258 |                       },
 259 |                     ),
 260 |                     const SizedBox(height: 8),
 261 |                     if (_isRegistering)
 262 |                       TextFormField(
 263 |                         controller: _confirmController,
 264 |                         textInputAction: TextInputAction.done,
 265 |                         obscureText: !_showConfirm,
 266 |                         autocorrect: false,
 267 |                         enableSuggestions: false,
 268 |                         autofillHints: const [AutofillHints.password],
 269 |                         decoration: InputDecoration(
 270 |                           labelText: 'Confirm password',
 271 |                           suffixIcon: IconButton(
 272 |                             tooltip: _showConfirm ? 'Hide password' : 'Show password',
 273 |                             icon: Icon(
 274 |                               _showConfirm ? Icons.visibility_off : Icons.visibility,
 275 |                             ),
 276 |                             onPressed: () {
 277 |                               setState(() => _showConfirm = !_showConfirm);
 278 |                             },
 279 |                           ),
 280 |                         ),
 281 |                         validator: _validateConfirm,
 282 |                         enabled: canSubmit,
 283 |                         onFieldSubmitted: (_) => _submit(),
 284 |                       ),
 285 |                     const SizedBox(height: 12),
 286 |                     Row(
 287 |                       children: [
 288 |                         Expanded(
 289 |                           child: FilledButton.icon(
 290 |                             onPressed: canSubmit ? _submit : null,
 291 |                             icon: _submitting
 292 |                                 ? const SizedBox(
 293 |                                     width: 16,
 294 |                                     height: 16,
 295 |                                     child: CircularProgressIndicator(strokeWidth: 2),
 296 |                                   )
 297 |                                 : Icon(_isRegistering
 298 |                                     ? Icons.person_add_alt_1
 299 |                                     : Icons.login),
 300 |                             label: Text(_isRegistering ? 'Create account' : 'Sign in'),
 301 |                           ),
 302 |                         ),
 303 |                       ],
 304 |                     ),
 305 |                     const SizedBox(height: 8),
 306 |                     Row(
 307 |                       children: [
 308 |                         TextButton(
 309 |                           onPressed: canSubmit
 310 |                               ? () {
 311 |                                   setState(() {
 312 |                                     _isRegistering = !_isRegistering;
 313 |                                     _error = null;
 314 |                                     _info = null;
 315 |                                   });
 316 |                                 }
 317 |                               : null,
 318 |                           child: Text(
 319 |                             _isRegistering
 320 |                                 ? 'Have an account? Sign in'
 321 |                                 : 'Create an account',
 322 |                           ),
 323 |                         ),
 324 |                         const Spacer(),
 325 |                         TextButton(
 326 |                           onPressed: (!_isRegistering && canSubmit) ? _sendPasswordReset : null,
 327 |                           child: _resetting
 328 |                               ? const SizedBox(
 329 |                                   width: 16,
 330 |                                   height: 16,
 331 |                                   child: CircularProgressIndicator(strokeWidth: 2),
 332 |                                 )
 333 |                               : const Text('Forgot password?'),
 334 |                         ),
 335 |                       ],
 336 |                     ),
 337 |                   ],
 338 |                 ),
 339 |               ),
 340 |             ),
 341 |             const SizedBox(height: 24),
 342 |             const Divider(),
 343 |             const SizedBox(height: 16),
 344 |             Text(
 345 |               'Guest',
 346 |               style: Theme.of(context)
 347 |                   .textTheme
 348 |                   .titleMedium
 349 |                   ?.copyWith(fontWeight: FontWeight.bold),
 350 |             ),
 351 |             const SizedBox(height: 8),
 352 |             FilledButton.icon(
 353 |               onPressed: _signInAnonymously,
 354 |               icon: const Icon(Icons.person_outline),
 355 |               label: const Text('Continue as Guest'),
 356 |             ),
 357 |             const SizedBox(height: 16),
 358 |             if (_error != null)
 359 |               Text(
 360 |                 _error!,
 361 |                 style: TextStyle(color: Theme.of(context).colorScheme.error),
 362 |               ),
 363 |             if (_info != null)
 364 |               Text(
 365 |                 _info!,
 366 |                 style: TextStyle(color: Theme.of(context).colorScheme.primary),
 367 |               ),
 368 |             if (isSignedIn)
 369 |               Padding(
 370 |                 padding: const EdgeInsets.only(top: 12),
 371 |                 child: Text(
 372 |                   'Signed in. You can close this page.',
 373 |                   style: Theme.of(context).textTheme.bodySmall,
 374 |                 ),
 375 |               ),
 376 |           ],
 377 |         ),
 378 |       ),
 379 |     );
 380 |   }
 381 | }
```

---

## `lib/features/saves/guest_migration.dart`
```dart
   1 | import 'dart:math';
   2 | 
   3 | import 'package:cloud_firestore/cloud_firestore.dart';
   4 | import 'package:shared_preferences/shared_preferences.dart';
   5 | import 'package:aft_firebase_app/data/aft_repository.dart';
   6 | import 'package:aft_firebase_app/data/aft_repository_firestore.dart';
   7 | 
   8 | class GuestMigration {
   9 |   // Prevent overlapping migrations from merging guest data twice.
  10 |   static final Map<String, Future<void>> _inFlight = {};
  11 | 
  12 |   /// Keys:
  13 |   /// - Guest bucket (legacy signed-out): scoreSets:guest
  14 |   /// - Guest bucket (anonymous): scoreSets:guest:{anonUid}
  15 |   /// - Legacy signed-in bucket (local): scoreSets:{uid}
  16 |   static String guestKey() => 'scoreSets:guest';
  17 |   static String guestKeyForUid(String uid) => 'scoreSets:guest:$uid';
  18 |   static String guestOwnerKey() => 'scoreSets:guestOwnerUid';
  19 |   static String lastAnonUidKey() => 'scoreSets:lastAnonUid';
  20 |   static String userKey(String uid) => 'scoreSets:$uid';
  21 |   static String migrationPendingKey(String uid) =>
  22 |       'scoreSets:migrationPending:$uid';
  23 |   static String migrationMarkerKey(String uid) =>
  24 |       'scoreSets:migrationMarker:$uid';
  25 |   static String migrationExpectedKey(String uid) =>
  26 |       'scoreSets:migrationExpected:$uid';
  27 |   static final Random _markerRng = Random();
  28 | 
  29 |   /// Migrates guest bucket into Firestore for the target uid if guest data exists.
  30 |   /// After migration, the guest bucket is cleared.
  31 |   static Future<void> maybeMigrateGuestTo(String uid) {
  32 |     final existing = _inFlight[uid];
  33 |     if (existing != null) return existing;
  34 |     final future = _runMigration(uid);
  35 |     _inFlight[uid] = future;
  36 |     return future.whenComplete(() => _inFlight.remove(uid));
  37 |   }
  38 | 
  39 |   static Future<void> trackGuestUser(String uid) async {
  40 |     final prefs = await SharedPreferences.getInstance();
  41 |     await prefs.setString(lastAnonUidKey(), uid);
  42 |   }
  43 | 
  44 |   static Future<void> _runMigration(String uid) async {
  45 |     final prefs = await SharedPreferences.getInstance();
  46 |     final guest = prefs.getString(guestKey());
  47 |     final existingUser = prefs.getString(userKey(uid));
  48 |     if ((guest == null || guest.isEmpty) &&
  49 |         (existingUser == null || existingUser.isEmpty)) {
  50 |       final anonUid = prefs.getString(lastAnonUidKey());
  51 |       if (anonUid == null || anonUid.isEmpty) return;
  52 |       final anonGuest = prefs.getString(guestKeyForUid(anonUid));
  53 |       if (anonGuest == null || anonGuest.isEmpty) return;
  54 |     }
  55 | 
  56 |     var guestSets =
  57 |         guest == null || guest.isEmpty ? <ScoreSet>[] : decodeScoreSets(guest);
  58 |     final userSets = existingUser == null || existingUser.isEmpty
  59 |         ? <ScoreSet>[]
  60 |         : decodeScoreSets(existingUser);
  61 |     final anonUid = prefs.getString(lastAnonUidKey());
  62 |     final anonGuest = anonUid == null ? null : prefs.getString(guestKeyForUid(anonUid));
  63 |     final anonSets = anonGuest == null || anonGuest.isEmpty
  64 |         ? <ScoreSet>[]
  65 |         : decodeScoreSets(anonGuest);
  66 |     final owner = prefs.getString(guestOwnerKey());
  67 |     if (guestSets.isNotEmpty && owner != null && owner != uid) {
  68 |       // Prevent cross-account migration of guest data on this device.
  69 |       guestSets = <ScoreSet>[];
  70 |     } else if (guestSets.isNotEmpty && owner == null) {
  71 |       await prefs.setString(guestOwnerKey(), uid);
  72 |     }
  73 |     final allSets = <String, ScoreSet>{};
  74 |     for (final set in guestSets) {
  75 |       allSets[set.id] = set;
  76 |     }
  77 |     for (final set in anonSets) {
  78 |       allSets[set.id] = set;
  79 |     }
  80 |     for (final set in userSets) {
  81 |       allSets[set.id] = set;
  82 |     }
  83 |     if (allSets.isEmpty) {
  84 |       if (guestSets.isEmpty) {
  85 |         await prefs.remove(guestKey());
  86 |       }
  87 |       if (anonSets.isEmpty && anonUid != null) {
  88 |         await prefs.remove(guestKeyForUid(anonUid));
  89 |         await prefs.remove(lastAnonUidKey());
  90 |       }
  91 |       if (userSets.isEmpty) {
  92 |         await prefs.remove(userKey(uid));
  93 |       }
  94 |       await _clearPending(prefs, uid);
  95 |       return;
  96 |     }
  97 | 
  98 |     final markerId = _newMarkerId();
  99 |     try {
 100 |       final firestore = FirebaseFirestore.instance;
 101 |       final userDoc = firestore.collection('users').doc(uid);
 102 |       final collection = userDoc.collection('scoreSets');
 103 | 
 104 |       WriteBatch batch = firestore.batch();
 105 |       var count = 0;
 106 |       for (final set in allSets.values) {
 107 |         final doc = collection.doc(set.id);
 108 |         batch.set(doc, scoreSetToFirestore(set), SetOptions(merge: true));
 109 |         count += 1;
 110 |         if (count >= 400) {
 111 |           await batch.commit();
 112 |           batch = firestore.batch();
 113 |           count = 0;
 114 |         }
 115 |       }
 116 |       batch.set(
 117 |         userDoc,
 118 |         {
 119 |           'migration': {
 120 |             'markerId': markerId,
 121 |             'expectedCount': allSets.length,
 122 |             'updatedAt': FieldValue.serverTimestamp(),
 123 |           }
 124 |         },
 125 |         SetOptions(merge: true),
 126 |       );
 127 |       await batch.commit();
 128 | 
 129 |       final verified = await _verifyMarker(uid, markerId);
 130 |       if (!verified) {
 131 |         await _markPending(prefs, uid, markerId, allSets.length);
 132 |         return;
 133 |       }
 134 | 
 135 |       if (guestSets.isNotEmpty) {
 136 |         await prefs.remove(guestKey());
 137 |         await prefs.remove(guestOwnerKey());
 138 |       }
 139 |       if (anonSets.isNotEmpty && anonUid != null) {
 140 |         await prefs.remove(guestKeyForUid(anonUid));
 141 |         await prefs.remove(lastAnonUidKey());
 142 |       }
 143 |       await prefs.remove(userKey(uid));
 144 |       await _clearPending(prefs, uid);
 145 |     } catch (_) {
 146 |       await _markPending(prefs, uid, markerId, allSets.length);
 147 |       // Keep guest data so migration can retry later.
 148 |     }
 149 |   }
 150 | 
 151 |   static String _newMarkerId() {
 152 |     final micros = DateTime.now().microsecondsSinceEpoch;
 153 |     final nonce = _markerRng.nextInt(1 << 32).toRadixString(16).padLeft(8, '0');
 154 |     return '$micros-$nonce';
 155 |   }
 156 | 
 157 |   static Future<bool> _verifyMarker(String uid, String markerId) async {
 158 |     try {
 159 |       final doc = await FirebaseFirestore.instance
 160 |           .collection('users')
 161 |           .doc(uid)
 162 |           .get(const GetOptions(source: Source.server));
 163 |       final data = doc.data();
 164 |       if (data == null) return false;
 165 |       final migration = data['migration'];
 166 |       if (migration is Map) {
 167 |         return migration['markerId'] == markerId;
 168 |       }
 169 |     } catch (_) {}
 170 |     return false;
 171 |   }
 172 | 
 173 |   static Future<void> _markPending(
 174 |     SharedPreferences prefs,
 175 |     String uid,
 176 |     String markerId,
 177 |     int expectedCount,
 178 |   ) async {
 179 |     await prefs.setBool(migrationPendingKey(uid), true);
 180 |     await prefs.setString(migrationMarkerKey(uid), markerId);
 181 |     await prefs.setInt(migrationExpectedKey(uid), expectedCount);
 182 |   }
 183 | 
 184 |   static Future<void> _clearPending(
 185 |     SharedPreferences prefs,
 186 |     String uid,
 187 |   ) async {
 188 |     await prefs.remove(migrationPendingKey(uid));
 189 |     await prefs.remove(migrationMarkerKey(uid));
 190 |     await prefs.remove(migrationExpectedKey(uid));
 191 |   }
 192 | }
```

---

## `lib/data/aft_repository.dart`
```dart
   1 | import 'dart:convert';
   2 | import 'dart:math';
   3 | 
   4 | import 'package:flutter/foundation.dart';
   5 | import 'package:aft_firebase_app/features/aft/state/aft_profile.dart';
   6 | import 'package:aft_firebase_app/features/aft/state/aft_inputs.dart';
   7 | import 'package:aft_firebase_app/features/aft/state/aft_standard.dart';
   8 | import 'package:aft_firebase_app/features/aft/state/providers.dart' show AftComputed;
   9 | 
  10 | @immutable
  11 | class ScoreSet {
  12 |   final String id;
  13 |   final AftProfile profile;
  14 |   final AftInputs inputs;
  15 |   final AftComputed? computed;
  16 |   final DateTime createdAt;
  17 |   static final Random _idRng = Random();
  18 | 
  19 |   ScoreSet({
  20 |     String? id,
  21 |     required this.profile,
  22 |     required this.inputs,
  23 |     required this.createdAt,
  24 |     this.computed,
  25 |   }) : id = id ?? _newId(createdAt);
  26 | 
  27 |   static String _newId(DateTime createdAt) {
  28 |     final micros = createdAt.microsecondsSinceEpoch;
  29 |     final nonce = _idRng.nextInt(1 << 32).toRadixString(16).padLeft(8, '0');
  30 |     return '$micros-$nonce';
  31 |   }
  32 | 
  33 |   Map<String, dynamic> toJson() => {
  34 |         'id': id,
  35 |         'profile': {
  36 |           'age': profile.age,
  37 |           'sex': profile.sex.name,
  38 |           'standard': profile.standard.name,
  39 |           'testDate': profile.testDate?.toIso8601String(),
  40 |         },
  41 |         'inputs': {
  42 |           'mdlLbs': inputs.mdlLbs,
  43 |           'pushUps': inputs.pushUps,
  44 |           'sdc': inputs.sdc?.inSeconds,
  45 |           'plank': inputs.plank?.inSeconds,
  46 |           'run2mi': inputs.run2mi?.inSeconds,
  47 |         },
  48 |         'computed': computed == null
  49 |             ? null
  50 |             : {
  51 |                 'mdlScore': computed!.mdlScore,
  52 |                 'pushUpsScore': computed!.pushUpsScore,
  53 |                 'sdcScore': computed!.sdcScore,
  54 |                 'plankScore': computed!.plankScore,
  55 |                 'run2miScore': computed!.run2miScore,
  56 |                 'total': computed!.total,
  57 |               },
  58 |         'createdAt': createdAt.toIso8601String(),
  59 |       };
  60 | 
  61 |   static ScoreSet fromJson(Map<String, dynamic> json) {
  62 |     final prof = json['profile'] as Map<String, dynamic>;
  63 |     final inp = json['inputs'] as Map<String, dynamic>;
  64 |     final comp = json['computed'] as Map<String, dynamic>?;
  65 | 
  66 |     final sex = AftSex.values.firstWhere(
  67 |       (e) => e.name == (prof['sex'] as String),
  68 |       orElse: () => AftSex.male,
  69 |     );
  70 |     final stdStr = prof['standard'] as String;
  71 |     final std = AftStandard.values.firstWhere(
  72 |       (e) => e.name == stdStr,
  73 |       orElse: () => AftStandard.general,
  74 |     );
  75 | 
  76 |     final profile = AftProfile(
  77 |       age: prof['age'] as int,
  78 |       sex: sex,
  79 |       standard: std,
  80 |       testDate: (prof['testDate'] as String?) == null
  81 |           ? null
  82 |           : DateTime.parse(prof['testDate'] as String),
  83 |     );
  84 | 
  85 |     final inputs = AftInputs(
  86 |       mdlLbs: inp['mdlLbs'] as int?,
  87 |       pushUps: inp['pushUps'] as int?,
  88 |       sdc: (inp['sdc'] as int?) == null
  89 |           ? null
  90 |           : Duration(seconds: inp['sdc'] as int),
  91 |       plank: (inp['plank'] as int?) == null
  92 |           ? null
  93 |           : Duration(seconds: inp['plank'] as int),
  94 |       run2mi: (inp['run2mi'] as int?) == null
  95 |           ? null
  96 |           : Duration(seconds: inp['run2mi'] as int),
  97 |     );
  98 | 
  99 |     final computed = comp == null
 100 |         ? null
 101 |         : AftComputed(
 102 |             mdlScore: comp['mdlScore'] as int?,
 103 |             pushUpsScore: comp['pushUpsScore'] as int?,
 104 |             sdcScore: comp['sdcScore'] as int?,
 105 |             plankScore: comp['plankScore'] as int?,
 106 |             run2miScore: comp['run2miScore'] as int?,
 107 |             total: comp['total'] as int?,
 108 |           );
 109 | 
 110 |     final id = (json['id'] as String?) ?? (json['createdAt'] as String);
 111 | 
 112 |     return ScoreSet(
 113 |       id: id,
 114 |       profile: profile,
 115 |       inputs: inputs,
 116 |       computed: computed,
 117 |       createdAt: DateTime.parse(json['createdAt'] as String),
 118 |     );
 119 |   }
 120 | }
 121 | 
 122 | /// Persistence boundary for AFT sets.
 123 | abstract class AftRepository {
 124 |   Future<void> saveScoreSet({
 125 |     required String userId,
 126 |     required ScoreSet set,
 127 |   });
 128 | 
 129 |   Future<void> updateScoreSet({
 130 |     required String userId,
 131 |     required ScoreSet set,
 132 |   });
 133 | 
 134 |   Future<void> deleteScoreSet({
 135 |     required String userId,
 136 |     required String id,
 137 |   });
 138 | 
 139 |   Future<void> clearScoreSets({
 140 |     required String userId,
 141 |   });
 142 | 
 143 |   Future<List<ScoreSet>> listScoreSets({
 144 |     required String userId,
 145 |   });
 146 | }
 147 | 
 148 | // Helpers for encoding lists
 149 | String encodeScoreSets(List<ScoreSet> sets) =>
 150 |     jsonEncode(sets.map((e) => e.toJson()).toList());
 151 | 
 152 | List<ScoreSet> decodeScoreSets(String source) {
 153 |   final list = (jsonDecode(source) as List).cast<dynamic>();
 154 |   return list
 155 |       .map((e) => ScoreSet.fromJson((e as Map).cast<String, dynamic>()))
 156 |       .toList();
 157 | }
```

---

## `lib/data/aft_repository_local.dart`
```dart
   1 | import 'package:shared_preferences/shared_preferences.dart';
   2 | import 'package:aft_firebase_app/data/aft_repository.dart';
   3 | 
   4 | /// Local implementation backed by shared_preferences.
   5 | /// Stores score sets under key: "scoreSets:{userId}" as a JSON list.
   6 | class LocalAftRepository implements AftRepository {
   7 |   String _keyFor(String userId) => 'scoreSets:$userId';
   8 | 
   9 |   @override
  10 |   Future<void> saveScoreSet({
  11 |     required String userId,
  12 |     required ScoreSet set,
  13 |   }) async {
  14 |     final prefs = await SharedPreferences.getInstance();
  15 |     final key = _keyFor(userId);
  16 |     final existing = prefs.getString(key);
  17 |     final list = existing == null ? <ScoreSet>[] : decodeScoreSets(existing);
  18 |     list.insert(0, set); // prepend newest
  19 |     await prefs.setString(key, encodeScoreSets(list));
  20 |   }
  21 | 
  22 |   @override
  23 |   Future<void> updateScoreSet({
  24 |     required String userId,
  25 |     required ScoreSet set,
  26 |   }) async {
  27 |     final prefs = await SharedPreferences.getInstance();
  28 |     final key = _keyFor(userId);
  29 |     final existing = prefs.getString(key);
  30 |     final list = existing == null ? <ScoreSet>[] : decodeScoreSets(existing);
  31 | 
  32 |     final idx = list.indexWhere((e) => e.id == set.id);
  33 |     if (idx >= 0) {
  34 |       // Replace in place to preserve list ordering and createdAt
  35 |       list[idx] = set;
  36 |     } else {
  37 |       // Fallback: if not found, insert as newest
  38 |       list.insert(0, set);
  39 |     }
  40 |     await prefs.setString(key, encodeScoreSets(list));
  41 |   }
  42 | 
  43 |   @override
  44 |   Future<void> deleteScoreSet({
  45 |     required String userId,
  46 |     required String id,
  47 |   }) async {
  48 |     final prefs = await SharedPreferences.getInstance();
  49 |     final key = _keyFor(userId);
  50 |     final existing = prefs.getString(key);
  51 |     if (existing == null) return;
  52 |     final list = decodeScoreSets(existing);
  53 |     list.removeWhere((e) => e.id == id);
  54 |     await prefs.setString(key, encodeScoreSets(list));
  55 |   }
  56 | 
  57 |   @override
  58 |   Future<void> clearScoreSets({
  59 |     required String userId,
  60 |   }) async {
  61 |     final prefs = await SharedPreferences.getInstance();
  62 |     final key = _keyFor(userId);
  63 |     // Remove the key entirely; listScoreSets will treat null as empty.
  64 |     await prefs.remove(key);
  65 |   }
  66 | 
  67 |   @override
  68 |   Future<List<ScoreSet>> listScoreSets({
  69 |     required String userId,
  70 |   }) async {
  71 |     final prefs = await SharedPreferences.getInstance();
  72 |     final key = _keyFor(userId);
  73 |     final existing = prefs.getString(key);
  74 |     if (existing == null) return <ScoreSet>[];
  75 |     return decodeScoreSets(existing);
  76 |   }
  77 | }
```

---

## `lib/data/repository_providers.dart`
```dart
   1 | import 'package:flutter_riverpod/flutter_riverpod.dart';
   2 | import 'package:aft_firebase_app/data/aft_repository.dart';
   3 | import 'package:aft_firebase_app/data/aft_repository_local.dart';
   4 | import 'package:aft_firebase_app/data/aft_repository_firestore.dart';
   5 | import 'package:aft_firebase_app/features/auth/providers.dart';
   6 | 
   7 | /// Bind the repository interface to local + Firestore implementations.
   8 | final aftRepositoryProvider = Provider<AftRepository>((ref) {
   9 |   final local = LocalAftRepository();
  10 |   final auth = ref.watch(firebaseAuthProvider);
  11 |   if (auth == null) return local;
  12 |   final user = ref.watch(authUserProvider);
  13 |   if (user == null) return DisabledAftRepository();
  14 |   final isGuest = user.isAnonymous;
  15 |   return HybridAftRepository(
  16 |     local: local,
  17 |     remote: FirestoreAftRepository(),
  18 |     isGuest: isGuest,
  19 |   );
  20 | });
  21 | 
  22 | class HybridAftRepository implements AftRepository {
  23 |   HybridAftRepository({
  24 |     required this.local,
  25 |     required this.remote,
  26 |     required this.isGuest,
  27 |   });
  28 | 
  29 |   final AftRepository local;
  30 |   final AftRepository remote;
  31 |   final bool isGuest;
  32 | 
  33 |   AftRepository _repoFor(String userId) {
  34 |     return isGuest ? local : remote;
  35 |   }
  36 | 
  37 |   @override
  38 |   Future<void> saveScoreSet({
  39 |     required String userId,
  40 |     required ScoreSet set,
  41 |   }) {
  42 |     return _repoFor(userId).saveScoreSet(userId: userId, set: set);
  43 |   }
  44 | 
  45 |   @override
  46 |   Future<void> updateScoreSet({
  47 |     required String userId,
  48 |     required ScoreSet set,
  49 |   }) {
  50 |     return _repoFor(userId).updateScoreSet(userId: userId, set: set);
  51 |   }
  52 | 
  53 |   @override
  54 |   Future<void> deleteScoreSet({
  55 |     required String userId,
  56 |     required String id,
  57 |   }) {
  58 |     return _repoFor(userId).deleteScoreSet(userId: userId, id: id);
  59 |   }
  60 | 
  61 |   @override
  62 |   Future<void> clearScoreSets({
  63 |     required String userId,
  64 |   }) {
  65 |     return _repoFor(userId).clearScoreSets(userId: userId);
  66 |   }
  67 | 
  68 |   @override
  69 |   Future<List<ScoreSet>> listScoreSets({
  70 |     required String userId,
  71 |   }) {
  72 |     return _repoFor(userId).listScoreSets(userId: userId);
  73 |   }
  74 | }
  75 | 
  76 | /// No-op repository used when signed out to prevent cross-account leakage.
  77 | class DisabledAftRepository implements AftRepository {
  78 |   @override
  79 |   Future<void> saveScoreSet({required String userId, required ScoreSet set}) async {}
  80 | 
  81 |   @override
  82 |   Future<void> updateScoreSet({required String userId, required ScoreSet set}) async {}
  83 | 
  84 |   @override
  85 |   Future<void> deleteScoreSet({required String userId, required String id}) async {}
  86 | 
  87 |   @override
  88 |   Future<void> clearScoreSets({required String userId}) async {}
  89 | 
  90 |   @override
  91 |   Future<List<ScoreSet>> listScoreSets({required String userId}) async => <ScoreSet>[];
  92 | }
```
